package verifiable_mixnet

import (
	"crypto/rand"
	"errors"
	"math/big"
	"runtime"
	"sync"

	"go.dedis.ch/kyber/v3"
	"go.dedis.ch/kyber/v3/suites"
)

type RoundConfiguration struct {
	ClientVerifiable bool // whether client submission is verifiable submission or not
	Verifiable       bool // whether this is a verifiable mixnet or not
	Row              int  // group id of this mixnet group within a layer
	Layer            int  // used if there are multiple layers
	Index            int  // index of this server in the mixnet group
	First            bool // whether this is the first server
	Last             bool // whether this is the last server
	AuxSize          int  // auxilary input length
	GroupSize        int  // size of the mix chain
}

var nWorkers = runtime.NumCPU()

// aux processors take in old ciphertext, new ciphertext, length of auxilary data
// returns valid or not
type AuxProcessor = func([]byte, []byte, int) (bool, []byte)

type DecryptionWorker = func(nonce *[NONCE_SIZE]byte, auxSize int, wg *sync.WaitGroup, jobs chan DecryptionJob)

// Mix is a single server on a mixnet group
type Mix interface {
	// Creates a new round. This does *not* generate encryption key.
	// Encryption keys are expected to be generated by outside routine,
	// and set through SetRoundKey
	NewRound(round int, config RoundConfiguration) error
	EndRound(round int) error

	// SetRoundKey sets the onion encryption key for the round.
	SetRoundKey(round int, publicKey, privateKey []byte) error
	// RoundKey returns the onion encryption key for the round.
	RoundKey(round int) ([]byte, error)
	//sets up a suite to use.
	SetRoundSuite(round int, suite suites.Suite) error
	// RoundConfiguration gets the config
	RoundConfiguration(round int) (RoundConfiguration, error)
	// SetAuxProcessor takes in a function that will be used to
	// process the auxilary data each ciphertext.
	// Takes ciphertext and aux length as input
	// returns some result, and whether the processing is successful
	SetAuxProcessor(round int, auxProcessor AuxProcessor) error

	// responsible for stopping the mixnet, cleaning resources and removing anything else.
	Terminate(round int) error

	// AddMessage takes in some messages and decrypt.
	AddMessages(round int, msgs [][]byte) error

	// Mix returns shuffled messages.
	Mix(round int) ([][]byte, error)
	// Shuffler returns the shuffler that shuffled the messages
	// can be used shuffle outside things that should match
	// the permutation of the messages
	Shuffler(round int) (*Shuffler, error)

	//////// Verifiable mixnet related functions ////////
	// AddCiphertexts saves ciphertext for later verification
	// also verifies client nizks for discrete log
	AddCiphertexts(round int, ciphertexts [][]byte, prfs [][]byte) error
	// SetBlindKey sets the blinding key for the round.
	SetBlindKey(round int, publicKeys [][]byte, privateKey []byte) error
	// BlindKey returns the blind key
	BlindKey(round int) ([]byte, error)
	// StartRound is used to setup relevant values once the ciphertexts
	// are submitted
	StartRound(round int) error
	// ProveMix returns the shuffled output,
	// and the proof of shuffle.
	ProveMix(round int) ([][]byte, []byte, error)
	// VerifyProof checks that out is a shuffled version of in.
	VerifyProof(round, index int, in [][]byte, proof []byte) error
	// ConfirmVerification is used to let a server know the proof
	// successfully verified.
	ConfirmVerification(round int, success bool) error
}

type server struct {
	smu    sync.RWMutex
	states map[int]*roundState
	dw     DecryptionWorker
}

func (srv *server) SetRoundSuite(round int, suite suites.Suite) error {
	srv.smu.RLock()
	state, ok := srv.states[round]
	srv.smu.RUnlock()
	if !ok {
		return errors.New("Mixnet-AddMessages: Round not yet started")
	}
	state.Lock()
	state.suite = suite
	state.Unlock()
	return nil
}

func (srv *server) Terminate(round int) error {
	srv.smu.RLock()
	state, ok := srv.states[round]
	srv.smu.RUnlock()
	if !ok {
		return errors.New("Mixnet-AddMessages: Round not yet started")
	}
	close(state.stop)
	state.msgAddWg.Wait()

	return srv.EndRound(round)
}

type DecryptionJob struct {
	PrivateKey   *[BOX_KEY_SIZE]byte
	Ciphertext   []byte
	AuxProcessor AuxProcessor

	PrivateBlindKey []byte

	Idx    int
	Result [][]byte

	// for verifiable decryption
	ProdWg          *sync.WaitGroup
	ProdJob         chan []byte
	KyberPrivateKey kyber.Scalar
}

type roundState struct {
	sync.Mutex

	config     RoundConfiguration
	privateKey *[BOX_KEY_SIZE]byte
	publicKey  []byte
	nonce      *[NONCE_SIZE]byte

	shuffler *Shuffler

	auxProcessor AuxProcessor

	cnt     int
	decWg   *sync.WaitGroup
	jobs    chan DecryptionJob
	results [][][]byte
	rlock   *sync.Mutex
	mixed   bool

	// verifiable shuffle states
	privateBlindKey []byte
	publicBlindKeys [][]byte

	ciphertexts [][]byte   // original ciphertexts
	dhkeys      [][][]byte // maps index to DH keys
	// used to take a product of the dh keys
	prodWgs         []*sync.WaitGroup
	prodJobs        []chan []byte
	partialProducts []chan []byte
	prodSet         []*sync.WaitGroup
	products        []point // maps index to the product
	verified        *sync.WaitGroup

	// used to terminate the mix
	stop chan bool
	// waits for all async writers to stop.
	msgAddWg        *sync.WaitGroup
	kyberPrivateKey kyber.Scalar
	suite           suites.Suite
}

func NewMix(dw DecryptionWorker) Mix {
	s := &server{
		states: make(map[int]*roundState),
		dw:     dw,
	}
	return s
}

func (srv *server) NewRound(round int, config RoundConfiguration) error {
	srv.smu.RLock()
	_, ok := srv.states[round]
	srv.smu.RUnlock()
	if ok {
		return errors.New("Round already exists")
	}

	nonce := Nonce(round, config.Row, config.Index)
	state := &roundState{
		config: config,
		nonce:  &nonce,

		shuffler: NewShuffler(rand.Reader),

		cnt:   0,
		decWg: new(sync.WaitGroup),
		jobs:  make(chan DecryptionJob, nWorkers),
		rlock: new(sync.Mutex),
		mixed: false,

		stop:     make(chan bool),
		msgAddWg: new(sync.WaitGroup),
	}

	dw := srv.dw
	if dw == nil {
		dw = defaultDecryptionWorker
	}

	for i := 0; i < nWorkers; i++ {
		go dw(&nonce, state.config.AuxSize, state.decWg, state.jobs)
	}

	if config.Verifiable {
		state.dhkeys = make([][][]byte, config.GroupSize)
		state.prodWgs = make([]*sync.WaitGroup, config.GroupSize)
		state.prodJobs = make([]chan []byte, config.GroupSize)
		state.partialProducts = make([]chan []byte, config.GroupSize)
		state.prodSet = make([]*sync.WaitGroup, config.GroupSize)
		state.products = make([]point, config.GroupSize)
		for i := 0; i < config.GroupSize; i++ {
			state.prodWgs[i] = new(sync.WaitGroup)
			state.prodJobs[i] = make(chan []byte, nWorkers)
			state.partialProducts[i] = make(chan []byte, nWorkers)
			state.prodSet[i] = new(sync.WaitGroup)
			state.prodSet[i].Add(1)
		}

		for w := range state.prodJobs {
			for i := 0; i < nWorkers; i++ {
				go productWorker(state.prodJobs[w], state.prodWgs[w],
					state.partialProducts[w])
			}
		}

		state.verified = new(sync.WaitGroup)
		state.verified.Add(config.GroupSize - 1)
	}

	srv.states[round] = state
	return nil
}

func (srv *server) EndRound(round int) error {
	srv.smu.RLock()
	state, ok := srv.states[round]
	srv.smu.RUnlock()
	if !ok {
		return errors.New("Round not yet started")
	}

	close(state.jobs)

	srv.smu.Lock()
	delete(srv.states, round)
	srv.smu.Unlock()
	return nil
}

func (srv *server) SetRoundKey(round int, publicKey, privateKey []byte) error {
	srv.smu.RLock()
	state, ok := srv.states[round]
	srv.smu.RUnlock()
	if !ok {
		return errors.New("Mixnet-SetRoundKey: Round not yet started")
	}
	var priv [BOX_KEY_SIZE]byte
	copy(priv[:], privateKey)

	state.publicKey = publicKey
	state.privateKey = &priv

	suite := state.suite
	if suite == nil {
		return nil
	}
	skey := suite.Scalar()
	if err := skey.UnmarshalBinary(privateKey); err == nil {
		state.kyberPrivateKey = skey
	}

	return nil
}

func (srv *server) RoundKey(round int) ([]byte, error) {
	srv.smu.RLock()
	state, ok := srv.states[round]
	srv.smu.RUnlock()
	if !ok {
		return nil, errors.New("Mixnet-RoundKey: Round not yet started")
	}
	return state.publicKey, nil
}

func (srv *server) RoundConfiguration(round int) (RoundConfiguration, error) {
	srv.smu.RLock()
	state, ok := srv.states[round]
	srv.smu.RUnlock()
	if !ok {
		return RoundConfiguration{}, errors.New("Mixnet-RoundConfiguration: Round not yet started")
	}
	return state.config, nil
}

func (srv *server) SetAuxProcessor(round int, auxProcessor AuxProcessor) error {
	srv.smu.RLock()
	state, ok := srv.states[round]
	srv.smu.RUnlock()
	if !ok {
		return errors.New("Mixnet-SetAuxProcessor: Round not yet started")
	}

	state.auxProcessor = auxProcessor
	return nil
}

func (srv *server) AddMessages(round int, msgs [][]byte) error {
	srv.smu.RLock()
	state, ok := srv.states[round]
	srv.smu.RUnlock()
	if !ok {
		return errors.New("Mixnet-AddMessages: Round not yet started")
	}

	result := make([][]byte, len(msgs))

	state.Lock()
	if state.mixed {
		state.Unlock()
		return errors.New("Current round has already been mixed")
	}
	state.results = append(state.results, result)
	state.cnt += len(msgs)
	state.Unlock()

	state.decWg.Add(len(msgs))

	state.msgAddWg.Add(1)
	go func(state *roundState) {
		defer state.msgAddWg.Done()

		// check if this round needs to stop before continuing
		select {
		case <-state.stop:
			return
		default:
		}

		for i, msg := range msgs {
			job := DecryptionJob{
				PrivateKey:      state.privateKey,
				Ciphertext:      msg,
				AuxProcessor:    state.auxProcessor,
				KyberPrivateKey: state.kyberPrivateKey,

				PrivateBlindKey: state.privateBlindKey,

				Idx:    i,
				Result: result,
			}

			if !state.config.Last && state.config.Verifiable {
				job.ProdWg = state.prodWgs[state.config.Index+1]
				job.ProdJob = state.prodJobs[state.config.Index+1]
			}

			select {
			case state.jobs <- job:
			case <-state.stop:
				return
			}
		}
	}(state)
	return nil
}

func (srv *server) Mix(round int) ([][]byte, error) {
	srv.smu.RLock()
	state, ok := srv.states[round]
	srv.smu.RUnlock()
	if !ok {
		return nil, errors.New("Mixnet-Mix: Round not yet started")
	}

	state.decWg.Wait()

	state.Lock()
	if state.mixed {
		state.Unlock()
		return nil, errors.New("Current round has already been mixed")
	}
	state.mixed = true
	state.Unlock()

	idx := 0
	result := make([][]byte, state.cnt)
	for _, res := range state.results {
		for _, r := range res {
			if r == nil {
				return nil, errors.New("Decryption failed")
			}
			result[idx] = r
			idx++
		}
	}

	state.shuffler.Shuffle(result)
	return result, nil
}

func (srv *server) Shuffler(round int) (*Shuffler, error) {
	srv.smu.RLock()
	state, ok := srv.states[round]
	srv.smu.RUnlock()
	if !ok {
		return nil, errors.New("Mixnet-Shuffler: Round not yet started")
	}
	return state.shuffler, nil
}

//////// verifiable mixnet related functions ////////

type clientNIZK struct {
	point []byte
	prf   []byte
	errs  chan error
}

func clientNIZKWorker(jobs chan clientNIZK) {
	x, y := new(big.Int), new(big.Int)
	for job := range jobs {
		x.SetBytes(job.point[:POINT_SIZE/2])
		y.SetBytes(job.point[POINT_SIZE/2 : POINT_SIZE])
		if !VerifyPoKLog(x, y, job.prf) {
			job.errs <- errors.New("Client NIZK verification failed")
		} else {
			job.errs <- nil
		}
	}
}

func (srv *server) AddCiphertexts(round int, ciphertexts [][]byte, prfs [][]byte) error {
	srv.smu.RLock()
	state, ok := srv.states[round]
	srv.smu.RUnlock()
	if !ok {
		return errors.New("Mixnet-AddCiphertext: Round not yet started")
	}

	state.Lock()
	// TODO: Write the ciphertext out to a file somewhere
	// state.ciphertexts = append(state.ciphertexts, ciphertexts...)
	for _, c := range ciphertexts {
		state.dhkeys[0] = append(state.dhkeys[0], c[:POINT_SIZE])
	}
	state.Unlock()

	state.prodWgs[0].Add(len(ciphertexts))
	go func() {
		for _, c := range ciphertexts {
			state.prodJobs[0] <- c[:POINT_SIZE]
		}
	}()

	if state.config.ClientVerifiable {
		jobs := make(chan clientNIZK, nWorkers)

		for i := 0; i < nWorkers; i++ {
			go clientNIZKWorker(jobs)
		}

		// verify discrete log nizks
		errs := make(chan error, nWorkers)
		go func() {
			for c := range ciphertexts {
				jobs <- clientNIZK{
					point: ciphertexts[c][:POINT_SIZE],
					prf:   prfs[c],
					errs:  errs,
				}
			}
			close(jobs)
		}()

		for range ciphertexts {
			err := <-errs
			if err != nil {
				return err
			}
		}
	}

	if state.config.First {
		return srv.AddMessages(round, ciphertexts)
	}

	return nil
}

func (srv *server) SetBlindKey(round int, publicKeys [][]byte, privateKey []byte) error {
	srv.smu.RLock()
	state, ok := srv.states[round]
	srv.smu.RUnlock()
	if !ok {
		return errors.New("Mixnet-SetBlindKey: Round not yet started")
	}
	state.publicBlindKeys = publicKeys
	state.privateBlindKey = privateKey
	return nil
}

func (srv *server) BlindKey(round int) ([]byte, error) {
	srv.smu.RLock()
	state, ok := srv.states[round]
	srv.smu.RUnlock()
	if !ok {
		return nil, errors.New("Mixnet-RoundKey: Round not yet started")
	}
	return state.publicBlindKeys[state.config.Index], nil
}

func productWorker(jobs chan []byte, wg *sync.WaitGroup, result chan []byte) {
	prodx, prody := big.NewInt(0), big.NewInt(0)
	x, y := new(big.Int), new(big.Int)
	for job := range jobs {
		x.SetBytes(job[:POINT_SIZE/2])
		y.SetBytes(job[POINT_SIZE/2 : POINT_SIZE])
		prodx, prody = curve.Add(prodx, prody, x, y)
		wg.Done()
	}

	res := make([]byte, POINT_SIZE)
	prodxb := prodx.Bytes()
	prodyb := prody.Bytes()
	copy(res[POINT_SIZE/2-len(prodxb):], prodxb)
	copy(res[POINT_SIZE-len(prodyb):], prodyb)

	result <- res
}

func (srv *server) gatherProducts(round, index int) (*big.Int, *big.Int) {
	state := srv.states[round]

	state.prodWgs[index].Wait()
	close(state.prodJobs[index]) // indicate no more keys will be added
	prodx, prody := big.NewInt(0), big.NewInt(0)
	x, y := new(big.Int), new(big.Int)
	for i := 0; i < nWorkers; i++ {
		res := <-state.partialProducts[index]
		x.SetBytes(res[:POINT_SIZE/2])
		y.SetBytes(res[POINT_SIZE/2 : POINT_SIZE])
		prodx, prody = curve.Add(prodx, prody, x, y)
	}

	state.products[index] = point{
		x: prodx,
		y: prody,
	}

	state.Lock()
	// TODO: save these keys for blame
	state.dhkeys[index] = nil
	state.Unlock()

	state.prodSet[index].Done()
	return prodx, prody
}

func (srv *server) StartRound(round int) error {
	srv.smu.RLock()
	_, ok := srv.states[round]
	srv.smu.RUnlock()
	if !ok {
		return errors.New("Mixnet-StartRound: Round not yet started")
	}

	srv.gatherProducts(round, 0)

	return nil
}

func (srv *server) ProveMix(round int) ([][]byte, []byte, error) {
	srv.smu.RLock()
	state, ok := srv.states[round]
	srv.smu.RUnlock()
	if !ok {
		return nil, nil, errors.New("Mixnet-ProveMix: Round not yet started")
	}

	index := state.config.Index

	// original product - serves as one of the bases for NIZK
	state.prodSet[index].Wait()
	ox := state.products[index].x
	oy := state.products[index].y

	shuffled, err := srv.Mix(round)
	if err != nil {
		return nil, nil, err
	}

	state.dhkeys[index+1] = make([][]byte, len(shuffled))
	for c := range shuffled {
		state.dhkeys[index+1][c] = shuffled[c][:POINT_SIZE]
	}

	// blinded product. the product jobs were computed as part of decryption
	bx, by := srv.gatherProducts(round, index+1)

	private := new(big.Int).SetBytes(state.privateBlindKey)
	publicx := new(big.Int).SetBytes(state.publicBlindKeys[index][:POINT_SIZE/2])
	publicy := new(big.Int).SetBytes(state.publicBlindKeys[index][POINT_SIZE/2 : POINT_SIZE])
	basex := curve.Params().Gx
	basey := curve.Params().Gy
	if index > 0 {
		basex = new(big.Int).SetBytes(state.publicBlindKeys[index-1][:POINT_SIZE/2])
		basey = new(big.Int).SetBytes(state.publicBlindKeys[index-1][POINT_SIZE/2 : POINT_SIZE])
	}

	prf := LogEquivalence(private, ox, oy, bx, by, basex, basey, publicx, publicy)

	// wait for all other servers to verify previous proof
	// NOTE: commented out because for crossroads,
	// this can be lazily checked due to double enveloping
	// state.verified.Wait()

	// clear the messages to avoid wasting space
	state.results = nil
	return shuffled, prf, nil
}

func (srv *server) VerifyProof(round, index int, in [][]byte, proof []byte) error {
	srv.smu.RLock()
	state, ok := srv.states[round]
	srv.smu.RUnlock()
	if !ok {
		return errors.New("Mixnet-VerifyProof: Round not yet started")
	}

	if state.config.Index <= index {
		// no need to verify downstream servers..
		close(state.prodJobs[index+1])
		return nil
	}

	state.dhkeys[index+1] = in
	state.prodWgs[index+1].Add(len(in))
	go func() {
		for _, c := range in {
			state.prodJobs[index+1] <- c[:POINT_SIZE]
		}
	}()

	state.prodSet[index].Wait()
	ox := state.products[index].x
	oy := state.products[index].y

	bx, by := srv.gatherProducts(round, index+1)

	basex := curve.Params().Gx
	basey := curve.Params().Gy
	if index > 0 {
		basex = new(big.Int).SetBytes(state.publicBlindKeys[index-1][:POINT_SIZE/2])
		basey = new(big.Int).SetBytes(state.publicBlindKeys[index-1][POINT_SIZE/2 : POINT_SIZE])
	}
	publicx := new(big.Int).SetBytes(state.publicBlindKeys[index][:POINT_SIZE/2])
	publicy := new(big.Int).SetBytes(state.publicBlindKeys[index][POINT_SIZE/2 : POINT_SIZE])

	eq := VerifyLogEquivalence(ox, oy, bx, by,
		basex, basey, publicx, publicy, proof)
	if !eq {
		return errors.New("Proof verification failed")
	}

	return nil
}

func (srv *server) ConfirmVerification(round int, success bool) error {
	srv.smu.RLock()
	state, ok := srv.states[round]
	srv.smu.RUnlock()
	if !ok {
		return errors.New("Mixnet-ConfirmVerification: Round not yet started")
	}

	if success {
		state.verified.Done()
	}
	return nil
}
